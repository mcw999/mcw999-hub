{
  "title": "Building an offline-first budget tracker in Flutter that actually works without internet",
  "body": "Second line empty\n\nSo I've been working on a personal budget tracker app for the past several months, and the single biggest pain point I kept running into wasn't UI design or state management — it was this: **the app was useless whenever my phone had spotty connectivity**.\n\nI commute by subway. Signal drops constantly. I'd try to log an expense right after buying coffee and the app would just... spin. Or worse, silently fail and I'd forget to record it later. Every commercial budgeting app I tried had the same problem — they're cloud-first, and when the cloud isn't available, neither is your data.\n\nIf you're building a Flutter finance app (or any data-entry mobile app, really), this problem is worth solving properly. Here's what I learned.\n\n---\n\n## Why offline-first matters more than you think\n\nThere's a difference between \"works offline\" and \"offline-first\". Most apps grudgingly tolerate offline mode — they'll cache some reads but refuse to write anything until the network comes back. Offline-first means your app is **designed assuming the network is unreliable**, and syncing is a background concern, not a gating requirement.\n\nFor a budget tracker specifically, this matters because:\n\n- Expenses happen at the point of purchase, which is often in a store basement, on a train, or somewhere with terrible signal\n- The longer the gap between spending and logging, the more you forget (or rationalize away)\n- Financial data is sensitive — you don't necessarily want it dependent on a third-party server being up\n\nThe core challenge is: how do you persist data locally, keep your UI reactive, and optionally sync when connectivity returns — all without making your codebase a nightmare?\n\n---\n\n## Local persistence: picking your storage layer\n\nIn Flutter, you've got a few realistic options for structured local data:\n\n**SQLite via `sqflite`** — the most flexible, good for complex queries, but you're writing raw SQL and managing schema migrations yourself.\n\n**`drift` (formerly Moor)** — type-safe SQLite wrapper with code generation. Great for anything relational. More boilerplate upfront but worth it.\n\n**`Hive`** — NoSQL key-value store, very fast, zero native dependencies (works on all platforms including web). Great for simpler data shapes.\n\n**`Isar`** — newer, fast, has a query language, works well with Flutter's reactive patterns.\n\nFor a budget tracker where the core entities are transactions and categories (and maybe budgets per period), I ended up using `drift` because I needed real queries — things like \"sum of expenses by category this month\" — that would've been painful with a pure key-value store.\n\nHere's a simplified version of the schema:\n\n```dart\n// database/tables.dart\nimport 'package:drift/drift.dart';\n\nclass Transactions extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 1, max: 100)();\n  RealColumn get amount => real()();\n  TextColumn get categoryId => text()();\n  IntColumn get type => intEnum<TransactionType>()(); // income or expense\n  DateTimeColumn get date => dateTime()();\n  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();\n}\n\nclass Categories extends Table {\n  TextColumn get id => text()();;\n  TextColumn get name => text()();\n  TextColumn get icon => text()();\n  TextColumn get colorHex => text()();\n\n  @override\n  Set<Column> get primaryKey => {id};\n}\n```\n\nThe `isSynced` column is key — it lets you track which records need to be pushed to a backend when connectivity returns, without blocking the user from entering data.\n\n---\n\n## Making the UI reactive to local data\n\nOne thing that took me longer than it should have to internalize: with `drift`, your queries return `Stream`s, not `Future`s. This means your UI automatically rebuilds when data changes. You don't need to manually refresh anything.\n\n```dart\n// In your repository\nStream<List<TransactionEntry>> watchTransactionsForMonth(DateTime month) {\n  final start = DateTime(month.year, month.month, 1);\n  final end = DateTime(month.year, month.month + 1, 0, 23, 59, 59);\n\n  return (select(transactions)\n        ..where((t) => t.date.isBetweenValues(start, end))\n        ..orderBy([(t) => OrderingTerm.desc(t.date)]))\n      .watch();\n}\n\n// And a derived query for the summary\nStream<double> watchMonthlyTotal(DateTime month, TransactionType type) {\n  final start = DateTime(month.year, month.month, 1);\n  final end = DateTime(month.year, month.month + 1, 0, 23, 59, 59);\n\n  final query = selectOnly(transactions)\n    ..addColumns([transactions.amount.sum()])\n    ..where(transactions.date.isBetweenValues(start, end))\n    ..where(transactions.type.equals(type.index));\n\n  return query.map((row) => row.read(transactions.amount.sum()) ?? 0.0).watchSingle();\n}\n```\n\nIn your widget, you pair this with a `StreamBuilder` (or use `riverpod` with `StreamProvider`, which is what I do in practice because it handles loading/error states more cleanly).\n\nThe result: you enter a transaction, it writes to local SQLite, the stream emits, the summary widget rebuilds. Zero network involved. Feels instant because it is instant.\n\n---\n\n## The \"how much do I have left today\" problem\n\nThe specific UX goal I had was: open the app, immediately see how much budget you have left for the day. Not this month, not this week — **today**. Because that's the decision you're making when you're standing at a register.\n\nThis means you need to calculate:\n\n```\ndaily_remaining = (monthly_budget / days_in_month) - expenses_today\n```\n\nBut that naive formula breaks down. What if you spent way over budget last week? Should that affect today's display? I found it more useful to show:\n\n```\ndaily_remaining = (monthly_budget - total_expenses_so_far) / days_remaining_in_month\n```\n\nThis \"rolling daily budget\" approach is more motivating — it tells you what you can actually spend for the rest of the month given where you are now, rather than pretending each day is independent.\n\nI keep this calculation in a simple domain service, not in the UI layer. Makes it easy to test.\n\n---\n\n## Handling sync when you do have connectivity\n\nIf you want to sync to a backend (I use a simple Supabase project), the pattern I settled on is:\n\n1. All writes go to local SQLite first, with `isSynced = false`\n2. A background sync service watches network connectivity using `connectivity_plus`\n3. When the network comes back, it queries for all records where `isSynced = false` and pushes them\n4. On success, it marks them as synced\n\nThe key design decision: **never block the user on sync**. The app doesn't wait for confirmation from the server. If the sync fails, the record stays marked as unsynced and the service will retry next time.\n\nYou do need to think about conflict resolution if the same app runs on multiple devices, but for a single-user personal finance app, \"last write wins\" is usually acceptable. Just make sure your records have a `updatedAt` timestamp so the server can sort it out.\n\n---\n\n## State management: keeping it sane\n\nI use `riverpod` because it plays well with streams from `drift` and handles async state cleanly. But the pattern that matters more than the specific library is keeping your layers clean:\n\n- **Database layer**: raw drift queries, returns streams/futures\n- **Repository layer**: wraps the database, exposes domain-friendly methods\n- **Provider layer**: exposes streams to the UI, handles transformations\n- **UI layer**: just reads state and dispatches events, no business logic\n\nWhen I broke this and put \"just a small calculation\" in a widget, I always regretted it during testing.\n\n---\n\n## A few things that bit me\n\n**Date handling**: Store dates as UTC in the database. Display in local time. Sounds obvious, but if you forget, you'll get off-by-one errors at midnight that are incredibly confusing to debug.\n\n**Schema migrations**: `drift` has a migration system, use it. Don't just delete and recreate the database during development — you'll train yourself into bad habits, and then when real users have the app, you'll have no idea how to migrate their data.\n\n**Large amount inputs**: Mobile keyboards are painful for entering amounts. A custom numeric keypad widget that feels like a calculator is worth the effort. Users entering `1234` is better UX than `1,234.00` in a text field.\n\n**Testing the offline state**: Use `connectivity_plus`'s mock in tests, and actually test what happens when sync fails. It's easy to only test the happy path and discover the offline behavior is broken right when you demo it to someone.\n\n---\n\n## What I actually shipped\n\nI put all of this together into 家計簿アプリ (Budget Tracker) — an offline-first Flutter app focused specifically on the \"what can I spend today\" use case. The whole point is that it works on the subway, at the store, wherever. You open it, you know your number, you log what you spend.\n\nThe architecture described above is pretty much exactly what's running in production. Local SQLite via drift, reactive streams for the UI, optional Supabase sync in the background.\n\n---\n\n## If you're starting from scratch\n\nMy honest recommendation for building something similar:\n\n1. Start with `drift` even if you think your data model is simple. You'll add queries you didn't anticipate.\n2. Design for offline from day one. Retrofitting offline support onto a cloud-first architecture is genuinely painful.\n3. Get the \"quick entry\" flow perfect before anything else. In a budget app, if logging a transaction takes more than 3 taps, people stop doing it.\n4. The \"daily remaining\" number is more actionable than monthly totals for most people — worth thinking about what the primary metric of your app actually is.\n\nThe offline-first constraint sounds like a limitation but it actually simplifies a lot of things. When you're not waiting on network requests, your UX becomes more predictable, your tests become simpler, and your users stop getting random loading spinners.\n\n---\n\nI wrote a more detailed guide on my blog covering the drift setup, the sync architecture, and the daily budget calculation logic in full: https://mcw999.github.io/mcw999-hub/blog/budget-tracker-guide/",
  "tags": [
    "webdev",
    "opensource",
    "javascript",
    "tutorial"
  ],
  "angle": "solve-their-problem"
}