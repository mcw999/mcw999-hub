{
  "originalSource": "qiita/2026-02-21-crypto-overheat-analyze.json",
  "title": "Cryptocurrency Market Overheating and Cooling Detection System Built with Node.js + TypeScript",
  "body": "# Cryptocurrency Market Overheating and Cooling Detection System Built with Node.js + TypeScript\n\nIn cryptocurrency trading, accurately identifying market overheating and cooling timing is extremely important. This article explains how to build a price, volume, and open interest data analysis system using the KuCoin Futures API to detect market signals in real-time.\n\n## System Overview\n\nThis system analyzes three key data points of the cryptocurrency market:\n\n- **Price Data**: Market trends and price volatility\n- **Volume Data**: Trading activity levels\n- **Open Interest Data**: Position accumulation status\n\nFrom this data, we detect four types of signals and classify market overheating/cooling states into four levels.\n\n## Tech Stack\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"typescript\": \"^5.0.0\",\n    \"node-fetch\": \"^3.3.0\",\n    \"@types/node\": \"^18.0.0\"\n  },\n  \"devDependencies\": {\n    \"vitest\": \"^0.34.0\",\n    \"@types/express\": \"^4.17.17\"\n  }\n}\n```\n\n## Project Structure\n\n```\nsrc/\n├── types/\n│   ├── market.ts\n│   └── signals.ts\n├── services/\n│   ├── kucoinApi.ts\n│   ├── signalDetector.ts\n│   └── coolingAnalyzer.ts\n├── utils/\n│   └── timeframe.ts\n├── routes/\n│   └── analysis.ts\n└── app.ts\n```\n\n## Type Definition Design\n\nFirst, let's define types for market data and signals:\n\n```typescript\n// types/market.ts\nexport interface MarketData {\n  timestamp: number;\n  price: number;\n  volume: number;\n  openInterest: number;\n  symbol: string;\n}\n\nexport type TimeFrame = 'HTF' | 'LTF';\nexport type HTFInterval = '4h' | '1d';\nexport type LTFInterval = '15m' | '1h';\n\n// types/signals.ts\nexport type SignalType = 'HIGH_ZONE' | 'PRICE_WEAK' | 'VOLUME_WEAK' | 'OI_SIGNAL';\nexport type CoolingLevel = 'confirmed' | 'watch' | 'mild' | 'none';\n\nexport interface DetectedSignal {\n  type: SignalType;\n  strength: number;\n  timestamp: number;\n  timeframe: TimeFrame;\n}\n\nexport interface CoolingAnalysis {\n  level: CoolingLevel;\n  signals: DetectedSignal[];\n  confidence: number;\n  recommendation: string;\n}\n```\n\n## KuCoin API Connection Service\n\nLet's implement a service to fetch data from the KuCoin Futures API:\n\n```typescript\n// services/kucoinApi.ts\nimport fetch from 'node-fetch';\n\nexport class KuCoinApiService {\n  private readonly baseUrl = 'https://api-futures.kucoin.com';\n  \n  async getKlineData(\n    symbol: string, \n    interval: string, \n    limit: number = 100\n  ): Promise<MarketData[]> {\n    try {\n      const endpoint = `/api/v1/kline/query`;\n      const params = new URLSearchParams({\n        symbol,\n        granularity: this.convertInterval(interval),\n        from: (Date.now() - limit * this.getIntervalMs(interval)).toString(),\n        to: Date.now().toString()\n      });\n\n      const response = await fetch(`${this.baseUrl}${endpoint}?${params}`);\n      const data = await response.json();\n      \n      return this.parseKlineData(data.data, symbol);\n    } catch (error) {\n      console.error('KuCoin API Error:', error);\n      throw new Error('Failed to fetch market data');\n    }\n  }\n\n  async getOpenInterest(symbol: string): Promise<number> {\n    const endpoint = `/api/v1/contracts/${symbol}`;\n    const response = await fetch(`${this.baseUrl}${endpoint}`);\n    const data = await response.json();\n    \n    return parseFloat(data.data.openInterest);\n  }\n\n  private convertInterval(interval: string): string {\n    const mapping: { [key: string]: string } = {\n      '15m': '900',\n      '1h': '3600',\n      '4h': '14400',\n      '1d': '86400'\n    };\n    return mapping[interval] || '3600';\n  }\n\n  private getIntervalMs(interval: string): number {\n    const mapping: { [key: string]: number } = {\n      '15m': 15 * 60 * 1000,\n      '1h': 60 * 60 * 1000,\n      '4h': 4 * 60 * 60 * 1000,\n      '1d': 24 * 60 * 60 * 1000\n    };\n    return mapping[interval] || 60 * 60 * 1000;\n  }\n\n  private parseKlineData(rawData: any[], symbol: string): MarketData[] {\n    return rawData.map(item => ({\n      timestamp: parseInt(item[0]),\n      price: parseFloat(item[2]), // close price\n      volume: parseFloat(item[5]),\n      openInterest: 0, // fetched separately\n      symbol\n    }));\n  }\n}\n```\n\n## Signal Detection Logic\n\nLet's implement a service that detects four types of signals:\n\n```typescript\n// services/signalDetector.ts\nexport class SignalDetector {\n  \n  detectHighZone(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 20) return null;\n    \n    const recent = data.slice(-5);\n    const historical = data.slice(-20, -5);\n    \n    const recentHigh = Math.max(...recent.map(d => d.price));\n    const historicalAvg = historical.reduce((sum, d) => sum + d.price, 0) / historical.length;\n    \n    const priceRatio = recentHigh / historicalAvg;\n    \n    if (priceRatio > 1.15) { // 15% or more increase\n      return {\n        type: 'HIGH_ZONE',\n        strength: Math.min((priceRatio - 1) * 100, 100),\n        timestamp: Date.now(),\n        timeframe: 'HTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectPriceWeak(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 10) return null;\n    \n    const recent = data.slice(-3);\n    const comparison = data.slice(-10, -3);\n    \n    // Detect declining price momentum\n    const recentSlope = this.calculateSlope(recent.map(d => d.price));\n    const comparisonSlope = this.calculateSlope(comparison.map(d => d.price));\n    \n    if (recentSlope < comparisonSlope * 0.5 && comparisonSlope > 0) {\n      return {\n        type: 'PRICE_WEAK',\n        strength: Math.abs(recentSlope - comparisonSlope) * 10,\n        timestamp: Date.now(),\n        timeframe: 'LTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectVolumeWeak(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 10) return null;\n    \n    const recentVolume = data.slice(-3).reduce((sum, d) => sum + d.volume, 0) / 3;\n    const avgVolume = data.slice(-10).reduce((sum, d) => sum + d.volume, 0) / 10;\n    \n    const volumeRatio = recentVolume / avgVolume;\n    \n    if (volumeRatio < 0.7) { // 30% or more volume decrease\n      return {\n        type: 'VOLUME_WEAK',\n        strength: (1 - volumeRatio) * 100,\n        timestamp: Date.now(),\n        timeframe: 'LTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectOISignal(data: MarketData[], currentOI: number): DetectedSignal | null {\n    if (data.length < 5) return null;\n    \n    const recentPriceChange = (data[data.length - 1].price - data[data.length - 5].price) / data[data.length - 5].price;\n    const avgOI = data.reduce((sum, d) => sum + d.openInterest, 0) / data.length;\n    \n    // Decreasing OI during price rise is an overheating signal\n    if (recentPriceChange > 0.05 && currentOI < avgOI * 0.9) {\n      return {\n        type: 'OI_SIGNAL',\n        strength: Math.abs(recentPriceChange) * 100,\n        timestamp: Date.now(),\n        timeframe: 'HTF'\n      };\n    }\n    \n    return null;\n  }\n\n  private calculateSlope(values: number[]): number {\n    const n = values.length;\n    const xSum = (n * (n - 1)) / 2;\n    const ySum = values.reduce((sum, val) => sum + val, 0);\n    const xySum = values.reduce((sum, val, i) => sum + i * val, 0);\n    const xSquareSum = (n * (n - 1) * (2 * n - 1)) / 6;\n    \n    return (n * xySum - xSum * ySum) / (n * xSquareSum - xSum * xSum);\n  }\n}\n```\n\n## Cooling Level Analysis\n\nIntegrate multiple signals to determine the cooling level:\n\n```typescript\n// services/coolingAnalyzer.ts\nexport class CoolingAnalyzer {\n  \n  analyzeCoolingLevel(signals: DetectedSignal[]): CoolingAnalysis {\n    const signalWeights = {\n      HIGH_ZONE: 0.4,\n      PRICE_WEAK: 0.2,\n      VOLUME_WEAK: 0.2,\n      OI_SIGNAL: 0.2\n    };\n    \n    let totalScore = 0;\n    let weightSum = 0;\n    \n    signals.forEach(signal => {\n      const weight = signalWeights[signal.type];\n      totalScore += signal.strength * weight;\n      weightSum += weight;\n    });\n    \n    const confidence = weightSum > 0 ? totalScore / (weightSum * 100) : 0;\n    const level = this.determineCoolingLevel(confidence, signals);\n    \n    return {\n      level,\n      signals,\n      confidence,\n      recommendation: this.generateRecommendation(level, confidence)\n    };\n  }\n  \n  private determineCoolingLevel(confidence: number, signals: DetectedSignal[]): CoolingLevel {\n    const highZoneSignal = signals.find(s => s.type === 'HIGH_ZONE');\n    const weaknessSignals = signals.filter(s => \n      s.type === 'PRICE_WEAK' || s.type === 'VOLUME_WEAK' || s.type === 'OI_SIGNAL'\n    );\n    \n    if (highZoneSignal && weaknessSignals.length >= 2 && confidence > 0.7) {\n      return 'confirmed';\n    } else if (highZoneSignal && weaknessSignals.length >= 1 && confidence > 0.5) {\n      return 'watch';\n    } else if (weaknessSignals.length >= 1 && confidence > 0.3) {\n      return 'mild';\n    }\n    \n    return 'none';\n  }\n  \n  private generateRecommendation(level: CoolingLevel, confidence: number): string {\n    const recommendations = {\n      confirmed: 'Market overheating confirmed. Consider reducing positions.',\n      watch: 'Signs of overheating detected. Monitor closely and prepare for profit-taking.',\n      mild: 'Mild bearish signals detected. Watch for trend changes.',\n      none: 'No clear overheating signals currently detected.'\n    };\n    \n    return recommendations[level];\n  }\n}\n```\n\n## Express API Endpoints\n\nImplement API endpoints to provide analysis results:\n\n```typescript\n// routes/analysis.ts\nimport { Router } from 'express';\nimport { KuCoinApiService } from '../services/kucoinApi';\nimport { SignalDetector } from '../services/signalDetector';\nimport { CoolingAnalyzer } from '../services/coolingAnalyzer';\n\nconst router = Router();\nconst apiService = new KuCoinApiService();\nconst signalDetector = new SignalDetector();\nconst coolingAnalyzer = new CoolingAnalyzer();\n\nrouter.get('/analyze/:symbol', async (req, res) => {\n  try {\n    const { symbol } = req.params;\n    const { timeframe = 'HTF', interval = '4h' } = req.query;\n    \n    // Fetch data\n    const marketData = await apiService.getKlineData(symbol, interval as string);\n    const currentOI = await apiService.getOpenInterest(symbol);\n    \n    // Integrate open interest data\n    marketData.forEach(data => data.openInterest = currentOI);\n    \n    // Detect signals\n    const signals = [\n      signalDetector.detectHighZone(marketData),\n      signalDetector.detectPriceWeak(marketData),\n      signalDetector.detectVolumeWeak(marketData),\n      signalDetector.detectOISignal(marketData, currentOI)\n    ].filter(signal => signal !== null);\n    \n    // Analyze cooling level\n    const analysis = coolingAnalyzer.analyzeCoolingLevel(signals);\n    \n    res.json({\n      symbol,\n      timeframe,\n      analysis,\n      timestamp: Date.now()\n    });\n    \n  } catch (error) {\n    console.error('Analysis error:', error);\n    res.status(500).json({ error: 'Analysis failed' });\n  }\n});\n\nexport default router;\n```\n\n## Test Implementation\n\nUnit testing with Vitest is also important:\n\n```typescript\n// tests/signalDetector.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { SignalDetector } from '../src/services/signalDetector';\nimport type { MarketData } from '../src/types/market';\n\ndescribe('SignalDetector', () => {\n  const detector = new SignalDetector();\n  \n  it('should detect high zone signal', () => {\n    const mockData: MarketData[] = Array.from({ length: 20 }, (_, i) => ({\n      timestamp: Date.now() - (20 - i) * 60000,\n      price: i < 15 ? 100 : 120, // Last 5 candles show 20% increase\n      volume: 1000,\n      openInterest: 5000,\n      symbol: 'BTCUSDT'\n    }));\n    \n    const signal = detector.detectHighZone(mockData);\n    \n    expect(signal).toBeTruthy();\n    expect(signal?.type).toBe('HIGH_ZONE');\n    expect(signal?.strength).toBeGreaterThan(15);\n  });\n  \n  it('should detect volume weakness', () => {\n    const mockData: MarketData[] = Array.from({ length: 10 }, (_, i) => ({\n      timestamp: Date.now() - (10 - i) * 60000,\n      price: 100,\n      volume: i < 7 ? 1000 : 500, // Last 3 candles show 50% volume drop\n      openInterest: 5000,\n      symbol: 'BTCUSDT'\n    }));\n    \n    const signal = detector.detectVolumeWeak(mockData);\n    \n    expect(signal).toBeTruthy();\n    expect(signal?.type).toBe('VOLUME_WEAK');\n  });\n});\n```\n\nThis system provides a comprehensive framework for detecting cryptocurrency market overheating and cooling",
  "tags": [
    "Node.js",
    "Express",
    "TypeScript",
    "Vitest"
  ]
}