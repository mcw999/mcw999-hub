{
  "title": "Building Location-Based AR Content Discovery with PostGIS and Three.js",
  "body": "When I started building a location-based AR platform, the part I thought would be easy turned out to be the hardest: efficiently querying which AR objects are \"near\" a user in real time, then rendering them correctly in 3D space relative to the camera. GPS coordinates feel simple until you're trying to do spatial radius queries on thousands of user-placed objects and then translate those coordinates into a Three.js scene that doesn't drift or jitter as the user moves.\n\nThis post is about that problem. If you're building anything with geo-anchored content — AR apps, location games, place-based social features — you've probably run into the same wall.\n\n## The Core Problem: Bridging GPS Space and 3D Render Space\n\nGPS gives you latitude and longitude (and sometimes altitude). Three.js works in a local coordinate system measured in meters (or whatever unit you define). These two worlds don't talk to each other naturally.\n\nThe naive approach is to just subtract coordinates:\n\n```javascript\n// DON'T do this\nconst dx = targetLon - userLon;\nconst dy = targetLat - userLat;\nobject.position.set(dx, 0, dy);\n```\n\nThis breaks down immediately because one degree of longitude near the equator is about 111km, but near the poles it's nearly zero. Your scene will look fine if you're testing in one place, then completely fall apart for users somewhere else — or even for the same user moving north.\n\nThe correct approach is to convert from WGS84 (GPS coordinates) to a local East-North-Up (ENU) coordinate system centered on the user's current position. This gives you actual metric distances in a flat plane.\n\n```javascript\n// Convert lat/lon to ENU coordinates relative to an origin point\nfunction gpsToENU(targetLat, targetLon, originLat, originLon) {\n  const R = 6371000; // Earth radius in meters\n  const dLat = (targetLat - originLat) * (Math.PI / 180);\n  const dLon = (targetLon - originLon) * (Math.PI / 180);\n\n  const avgLat = ((targetLat + originLat) / 2) * (Math.PI / 180);\n\n  // East (X) and North (Z) in meters\n  const east = R * dLon * Math.cos(avgLat);\n  const north = R * dLat;\n\n  // In Three.js, Z is depth (into screen), so we negate north for alignment\n  return { x: east, y: 0, z: -north };\n}\n\n// Usage\nconst userPos = { lat: 35.6812, lon: 139.7671 }; // Tokyo example\nconst anchorPos = { lat: 35.6815, lon: 139.7680 };\n\nconst enuCoords = gpsToENU(\n  anchorPos.lat, anchorPos.lon,\n  userPos.lat, userPos.lon\n);\n\narObject.position.set(enuCoords.x, enuCoords.y, enuCoords.z);\n```\n\nThe key insight: you recalculate this every time the user moves. The origin is always the user's current position, so objects near them are close to (0,0,0) in scene space and objects far away are simply further from origin. This keeps your floating point numbers small and precise, which matters a lot for AR stability.\n\n## The Database Side: Spatial Queries with PostGIS\n\nBefore you can render anything, you need to know which AR objects exist near the user. This is where a lot of people reach for a simple \"find all objects and filter client-side\" approach. Works fine at 100 objects. Terrible at 50,000.\n\nPostGIS on top of Postgres (which Supabase uses) gives you proper spatial indexing. Here's the table setup:\n\n```sql\n-- Enable PostGIS extension (already enabled in Supabase)\ncreate extension if not exists postgis;\n\n-- AR content anchors table\ncreate table ar_anchors (\n  id uuid primary key default gen_random_uuid(),\n  user_id uuid references auth.users(id),\n  title text not null,\n  content_type text check (content_type in ('3d_model', 'text', 'photo')),\n  content_url text,\n  metadata jsonb default '{}',\n  location geography(Point, 4326) not null,\n  created_at timestamptz default now()\n);\n\n-- Spatial index — critical for performance\ncreate index ar_anchors_location_idx \n  on ar_anchors using gist(location);\n\n-- Query: find anchors within 500 meters of user\n-- You'd call this via a Supabase RPC or directly\nselect \n  id,\n  title,\n  content_type,\n  content_url,\n  metadata,\n  ST_Y(location::geometry) as lat,\n  ST_X(location::geometry) as lon,\n  ST_Distance(\n    location, \n    ST_MakePoint(139.7671, 35.6812)::geography\n  ) as distance_meters\nfrom ar_anchors\nwhere ST_DWithin(\n  location,\n  ST_MakePoint(139.7671, 35.6812)::geography,\n  500  -- radius in meters\n)\norder by distance_meters asc;\n```\n\n`ST_DWithin` with a geography type gives you geodesic distance calculations that are accurate regardless of where on earth you are. It also uses your spatial index, so this query stays fast even with a lot of data.\n\nIn Supabase you'd expose this as an RPC function and call it from your client whenever the user's position changes significantly (I use a 10-meter threshold to avoid spamming queries on every GPS tick).\n\n## Handling the Camera Orientation Problem\n\nHere's where things get tricky for actual AR. You need to align your Three.js camera with the physical direction the device is facing. The DeviceOrientationEvent gives you alpha (compass heading), beta (tilt), and gamma (roll). Mapping these to a Three.js camera rotation without gimbal lock or drift is genuinely annoying.\n\nA few things I learned the hard way:\n\n**Don't use Euler angles directly.** The order matters and you'll spend hours debugging rotation weirdness. Use quaternions.\n\n**Alpha isn't always compass-relative.** On iOS, alpha is relative to the initial orientation when the page loaded. On Android with Chrome, it's relative to magnetic north. You need to handle both cases, ideally by requesting `requestPermission` on iOS and checking `absolute` on the DeviceOrientationEvent.\n\n**The drift problem is real.** Magnetometers in phones are noisy. Any metal nearby (a car, a building with rebar) will throw off your compass. You can apply a low-pass filter to smooth jitter, but there's no perfect solution — this is a hardware limitation.\n\n```javascript\n// Simplified camera orientation from device sensors\nfunction updateCameraOrientation(event, camera) {\n  // event.alpha = heading (degrees, 0-360)\n  // event.beta = tilt front/back (-180 to 180)\n  // event.gamma = tilt left/right (-90 to 90)\n  \n  if (event.alpha === null) return;\n\n  const alphaRad = (event.alpha * Math.PI) / 180;\n  const betaRad = (event.beta * Math.PI) / 180;\n  const gammaRad = (event.gamma * Math.PI) / 180;\n\n  // Build rotation quaternion — ZXY order matches device orientation spec\n  const euler = new THREE.Euler(betaRad, alphaRad, -gammaRad, 'ZXY');\n  const quaternion = new THREE.Quaternion().setFromEuler(euler);\n\n  // Apply a correction for screen orientation if needed\n  const screenOrientation = window.screen.orientation?.angle ?? 0;\n  const screenQuat = new THREE.Quaternion().setFromAxisAngle(\n    new THREE.Vector3(0, 0, 1),\n    (-screenOrientation * Math.PI) / 180\n  );\n\n  camera.quaternion.copy(quaternion.multiply(screenQuat));\n}\n\n// Attach listener\nwindow.addEventListener('deviceorientation', (e) => {\n  updateCameraOrientation(e, myThreeCamera);\n}, true);\n```\n\nEven with this, you'll notice the camera \"drifts\" slightly over time on many devices. Some teams add a manual calibration step where users point their phone at a QR code or a known landmark to reset the heading. For social AR where exact precision isn't critical, a slight drift is often acceptable — users are forgiving if a virtual object is a few degrees off from where it \"should\" be.\n\n## PWA vs Native: What Actually Matters Here\n\nIf you're doing this as a PWA (which I am with CityCanvas), you face one specific limitation: `DeviceOrientationEvent` requires either HTTPS or a permission prompt on iOS 13+. Make absolutely sure your deployment is HTTPS, otherwise you'll get zero sensor data and no useful error message.\n\nCapacitor (which wraps your web app as a native app) gives you access to native AR frameworks if you need them — ARKit on iOS, ARCore on Android. These handle a lot of the sensor fusion for you and give much better tracking. But they also add significant complexity to your build pipeline. For a first version, I'd suggest getting the web-based approach working first, then considering Capacitor/native AR as an enhancement.\n\nThe PWA approach also lets you test quickly in a browser on desktop using a webcam and keyboard controls simulating GPS movement, which is way faster than deploying to a phone every time.\n\n## What I'd Do Differently\n\nLooking back at the architecture decisions:\n\n**Start with a smaller search radius than you think you need.** 500 meters sounds reasonable but if users are placing lots of content, that's potentially hundreds of objects in a city center. I now paginate the results and only fully load models for objects within 100 meters, showing simpler \"beacon\" markers for anything 100-500m away.\n\n**Think about content loading budget from day one.** Fetching a 3D model for every anchor in range will destroy load times. You need LOD (level of detail) — simple sprites far away, full 3D models close up. Three.js has a `LOD` class for this.\n\n**GPS accuracy is wildly variable.** In dense urban environments (tall buildings, the \"urban canyon\" effect), GPS can be off by 20-50 meters. Design your UX so a 20m placement error isn't catastrophic. Making objects bigger, or giving users a visual \"search\" interaction rather than just walking to an exact spot, both help.\n\n**Don't try to solve all the hard AR problems at once.** Surface tracking, occlusion, persistent anchors across sessions — these are research-level problems. Ship something that's fun with imperfect GPS and orientation, then iterate.\n\nThe geo + 3D rendering combination is genuinely one of the more interesting technical areas right now, and there's a lot of room to build things that weren't possible a few years ago just using browser APIs and cheap cloud databases. Most of the hard stuff is solvable with the approaches above — the magic is in what you let users create and discover with it.\n\nI wrote a more detailed guide on my blog covering the full architecture including the 3D model generation pipeline and Capacitor setup: https://mcw999.github.io/mcw999-hub/blog/city-canvas-guide/",
  "tags": [
    "webdev",
    "opensource",
    "javascript",
    "tutorial"
  ],
  "angle": "solve-their-problem"
}