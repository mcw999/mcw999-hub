{
  "title": "Node.js + TypeScriptで構築する暗号通貨市場の過熱冷却検出システム",
  "body": "# Node.js + TypeScriptで構築する暗号通貨市場の過熱冷却検出システム\n\n暗号通貨取引において、市場の過熱や冷却タイミングを正確に把握することは非常に重要です。今回は、KuCoin Futures APIを活用した価格・出来高・建玉データの分析システムを構築し、リアルタイムで市場のシグナルを検出する方法について解説します。\n\n## システム概要\n\nこのシステムは、暗号通貨市場の以下3つの主要データを分析します：\n\n- **価格データ**: 市場のトレンドと価格変動\n- **出来高データ**: 取引活動の活発度\n- **建玉データ（Open Interest）**: ポジションの蓄積状況\n\nこれらのデータから4種類のシグナルを検出し、市場の過熱・冷却状態を4段階で分類します。\n\n## 技術スタック\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"typescript\": \"^5.0.0\",\n    \"node-fetch\": \"^3.3.0\",\n    \"@types/node\": \"^18.0.0\"\n  },\n  \"devDependencies\": {\n    \"vitest\": \"^0.34.0\",\n    \"@types/express\": \"^4.17.17\"\n  }\n}\n```\n\n## プロジェクト構造\n\n```\nsrc/\n├── types/\n│   ├── market.ts\n│   └── signals.ts\n├── services/\n│   ├── kucoinApi.ts\n│   ├── signalDetector.ts\n│   └── coolingAnalyzer.ts\n├── utils/\n│   └── timeframe.ts\n├── routes/\n│   └── analysis.ts\n└── app.ts\n```\n\n## 型定義の設計\n\nまず、市場データとシグナルの型を定義します：\n\n```typescript\n// types/market.ts\nexport interface MarketData {\n  timestamp: number;\n  price: number;\n  volume: number;\n  openInterest: number;\n  symbol: string;\n}\n\nexport type TimeFrame = 'HTF' | 'LTF';\nexport type HTFInterval = '4h' | '1d';\nexport type LTFInterval = '15m' | '1h';\n\n// types/signals.ts\nexport type SignalType = 'HIGH_ZONE' | 'PRICE_WEAK' | 'VOLUME_WEAK' | 'OI_SIGNAL';\nexport type CoolingLevel = 'confirmed' | 'watch' | 'mild' | 'none';\n\nexport interface DetectedSignal {\n  type: SignalType;\n  strength: number;\n  timestamp: number;\n  timeframe: TimeFrame;\n}\n\nexport interface CoolingAnalysis {\n  level: CoolingLevel;\n  signals: DetectedSignal[];\n  confidence: number;\n  recommendation: string;\n}\n```\n\n## KuCoin API接続サービス\n\nKuCoin Futures APIからデータを取得するサービスを実装します：\n\n```typescript\n// services/kucoinApi.ts\nimport fetch from 'node-fetch';\n\nexport class KuCoinApiService {\n  private readonly baseUrl = 'https://api-futures.kucoin.com';\n  \n  async getKlineData(\n    symbol: string, \n    interval: string, \n    limit: number = 100\n  ): Promise<MarketData[]> {\n    try {\n      const endpoint = `/api/v1/kline/query`;\n      const params = new URLSearchParams({\n        symbol,\n        granularity: this.convertInterval(interval),\n        from: (Date.now() - limit * this.getIntervalMs(interval)).toString(),\n        to: Date.now().toString()\n      });\n\n      const response = await fetch(`${this.baseUrl}${endpoint}?${params}`);\n      const data = await response.json();\n      \n      return this.parseKlineData(data.data, symbol);\n    } catch (error) {\n      console.error('KuCoin API Error:', error);\n      throw new Error('Failed to fetch market data');\n    }\n  }\n\n  async getOpenInterest(symbol: string): Promise<number> {\n    const endpoint = `/api/v1/contracts/${symbol}`;\n    const response = await fetch(`${this.baseUrl}${endpoint}`);\n    const data = await response.json();\n    \n    return parseFloat(data.data.openInterest);\n  }\n\n  private convertInterval(interval: string): string {\n    const mapping: { [key: string]: string } = {\n      '15m': '900',\n      '1h': '3600',\n      '4h': '14400',\n      '1d': '86400'\n    };\n    return mapping[interval] || '3600';\n  }\n\n  private getIntervalMs(interval: string): number {\n    const mapping: { [key: string]: number } = {\n      '15m': 15 * 60 * 1000,\n      '1h': 60 * 60 * 1000,\n      '4h': 4 * 60 * 60 * 1000,\n      '1d': 24 * 60 * 60 * 1000\n    };\n    return mapping[interval] || 60 * 60 * 1000;\n  }\n\n  private parseKlineData(rawData: any[], symbol: string): MarketData[] {\n    return rawData.map(item => ({\n      timestamp: parseInt(item[0]),\n      price: parseFloat(item[2]), // close price\n      volume: parseFloat(item[5]),\n      openInterest: 0, // 別途取得\n      symbol\n    }));\n  }\n}\n```\n\n## シグナル検出ロジック\n\n4種類のシグナルを検出するサービスを実装します：\n\n```typescript\n// services/signalDetector.ts\nexport class SignalDetector {\n  \n  detectHighZone(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 20) return null;\n    \n    const recent = data.slice(-5);\n    const historical = data.slice(-20, -5);\n    \n    const recentHigh = Math.max(...recent.map(d => d.price));\n    const historicalAvg = historical.reduce((sum, d) => sum + d.price, 0) / historical.length;\n    \n    const priceRatio = recentHigh / historicalAvg;\n    \n    if (priceRatio > 1.15) { // 15%以上の上昇\n      return {\n        type: 'HIGH_ZONE',\n        strength: Math.min((priceRatio - 1) * 100, 100),\n        timestamp: Date.now(),\n        timeframe: 'HTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectPriceWeak(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 10) return null;\n    \n    const recent = data.slice(-3);\n    const comparison = data.slice(-10, -3);\n    \n    // 価格の勢い低下を検出\n    const recentSlope = this.calculateSlope(recent.map(d => d.price));\n    const comparisonSlope = this.calculateSlope(comparison.map(d => d.price));\n    \n    if (recentSlope < comparisonSlope * 0.5 && comparisonSlope > 0) {\n      return {\n        type: 'PRICE_WEAK',\n        strength: Math.abs(recentSlope - comparisonSlope) * 10,\n        timestamp: Date.now(),\n        timeframe: 'LTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectVolumeWeak(data: MarketData[]): DetectedSignal | null {\n    if (data.length < 10) return null;\n    \n    const recentVolume = data.slice(-3).reduce((sum, d) => sum + d.volume, 0) / 3;\n    const avgVolume = data.slice(-10).reduce((sum, d) => sum + d.volume, 0) / 10;\n    \n    const volumeRatio = recentVolume / avgVolume;\n    \n    if (volumeRatio < 0.7) { // 30%以上の出来高減少\n      return {\n        type: 'VOLUME_WEAK',\n        strength: (1 - volumeRatio) * 100,\n        timestamp: Date.now(),\n        timeframe: 'LTF'\n      };\n    }\n    \n    return null;\n  }\n\n  detectOISignal(data: MarketData[], currentOI: number): DetectedSignal | null {\n    if (data.length < 5) return null;\n    \n    const recentPriceChange = (data[data.length - 1].price - data[data.length - 5].price) / data[data.length - 5].price;\n    const avgOI = data.reduce((sum, d) => sum + d.openInterest, 0) / data.length;\n    \n    // 価格上昇中のOI減少は過熱シグナル\n    if (recentPriceChange > 0.05 && currentOI < avgOI * 0.9) {\n      return {\n        type: 'OI_SIGNAL',\n        strength: Math.abs(recentPriceChange) * 100,\n        timestamp: Date.now(),\n        timeframe: 'HTF'\n      };\n    }\n    \n    return null;\n  }\n\n  private calculateSlope(values: number[]): number {\n    const n = values.length;\n    const xSum = (n * (n - 1)) / 2;\n    const ySum = values.reduce((sum, val) => sum + val, 0);\n    const xySum = values.reduce((sum, val, i) => sum + i * val, 0);\n    const xSquareSum = (n * (n - 1) * (2 * n - 1)) / 6;\n    \n    return (n * xySum - xSum * ySum) / (n * xSquareSum - xSum * xSum);\n  }\n}\n```\n\n## 冷却レベル分析\n\n複数シグナルを統合して冷却レベルを判定します：\n\n```typescript\n// services/coolingAnalyzer.ts\nexport class CoolingAnalyzer {\n  \n  analyzeCoolingLevel(signals: DetectedSignal[]): CoolingAnalysis {\n    const signalWeights = {\n      HIGH_ZONE: 0.4,\n      PRICE_WEAK: 0.2,\n      VOLUME_WEAK: 0.2,\n      OI_SIGNAL: 0.2\n    };\n    \n    let totalScore = 0;\n    let weightSum = 0;\n    \n    signals.forEach(signal => {\n      const weight = signalWeights[signal.type];\n      totalScore += signal.strength * weight;\n      weightSum += weight;\n    });\n    \n    const confidence = weightSum > 0 ? totalScore / (weightSum * 100) : 0;\n    const level = this.determineCoolingLevel(confidence, signals);\n    \n    return {\n      level,\n      signals,\n      confidence,\n      recommendation: this.generateRecommendation(level, confidence)\n    };\n  }\n  \n  private determineCoolingLevel(confidence: number, signals: DetectedSignal[]): CoolingLevel {\n    const highZoneSignal = signals.find(s => s.type === 'HIGH_ZONE');\n    const weaknessSignals = signals.filter(s => \n      s.type === 'PRICE_WEAK' || s.type === 'VOLUME_WEAK' || s.type === 'OI_SIGNAL'\n    );\n    \n    if (highZoneSignal && weaknessSignals.length >= 2 && confidence > 0.7) {\n      return 'confirmed';\n    } else if (highZoneSignal && weaknessSignals.length >= 1 && confidence > 0.5) {\n      return 'watch';\n    } else if (weaknessSignals.length >= 1 && confidence > 0.3) {\n      return 'mild';\n    }\n    \n    return 'none';\n  }\n  \n  private generateRecommendation(level: CoolingLevel, confidence: number): string {\n    const recommendations = {\n      confirmed: '市場過熱が確認されました。ポジション縮小を検討してください。',\n      watch: '過熱の兆候が見られます。注意深く監視し、利確の準備をしてください。',\n      mild: '軽微な弱気シグナルが検出されました。トレンド変化に注意してください。',\n      none: '現在、明確な過熱シグナルは検出されていません。'\n    };\n    \n    return recommendations[level];\n  }\n}\n```\n\n## Express APIエンドポイント\n\n分析結果を提供するAPIエンドポイントを実装します：\n\n```typescript\n// routes/analysis.ts\nimport { Router } from 'express';\nimport { KuCoinApiService } from '../services/kucoinApi';\nimport { SignalDetector } from '../services/signalDetector';\nimport { CoolingAnalyzer } from '../services/coolingAnalyzer';\n\nconst router = Router();\nconst apiService = new KuCoinApiService();\nconst signalDetector = new SignalDetector();\nconst coolingAnalyzer = new CoolingAnalyzer();\n\nrouter.get('/analyze/:symbol', async (req, res) => {\n  try {\n    const { symbol } = req.params;\n    const { timeframe = 'HTF', interval = '4h' } = req.query;\n    \n    // データ取得\n    const marketData = await apiService.getKlineData(symbol, interval as string);\n    const currentOI = await apiService.getOpenInterest(symbol);\n    \n    // 建玉データを統合\n    marketData.forEach(data => data.openInterest = currentOI);\n    \n    // シグナル検出\n    const signals = [\n      signalDetector.detectHighZone(marketData),\n      signalDetector.detectPriceWeak(marketData),\n      signalDetector.detectVolumeWeak(marketData),\n      signalDetector.detectOISignal(marketData, currentOI)\n    ].filter(signal => signal !== null);\n    \n    // 冷却レベル分析\n    const analysis = coolingAnalyzer.analyzeCoolingLevel(signals);\n    \n    res.json({\n      symbol,\n      timeframe,\n      analysis,\n      timestamp: Date.now()\n    });\n    \n  } catch (error) {\n    console.error('Analysis error:', error);\n    res.status(500).json({ error: 'Analysis failed' });\n  }\n});\n\nexport default router;\n```\n\n## テスト実装\n\nVitestを使用したユニットテストも重要です：\n\n```typescript\n// tests/signalDetector.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { SignalDetector } from '../src/services/signalDetector';\nimport type { MarketData } from '../src/types/market';\n\ndescribe('SignalDetector', () => {\n  const detector = new SignalDetector();\n  \n  it('should detect high zone signal', () => {\n    const mockData: MarketData[] = Array.from({ length: 20 }, (_, i) => ({\n      timestamp: Date.now() - (20 - i) * 60000,\n      price: i < 15 ? 100 : 120, // 最後",
  "tags": [
    "Node.js",
    "Express",
    "TypeScript",
    "Vitest"
  ]
}