{
  "title": "TauriデスクトップアプリでPRコンテンツ生成パイプラインを実装した記録",
  "body": "---\n\n個人開発者として複数のプロジェクトを持つようになると、「作った、でも誰にも知られていない」という状況に陥りがちです。Twitter・Qiita・Zenn・Dev.to・Redditといった各プラットフォームへの投稿を手作業でやろうとすると、一件ずつコンテンツを書いてコピペして……という作業が積み重なり、結局投稿頻度がゼロになる。そこで、PRコンテンツ生成から投稿まで全体をTauriデスクトップアプリで一元管理するPRダッシュボードを作りました。\n\nこの記事では、実装中に詰まった箇所や失敗談を正直に書き残します。\n\n---\n\n## 最初の失敗：SendKeysによるClaude CLI操作\n\n最初のアプローチは「Claude CLIをバックグラウンドで起動して、PowerShellのSendKeysでフォルダ信頼の承認ダイアログ→プロンプト貼り付け→Enter送信という一連の操作を自動化する」というものでした。\n\n```rust\n// 当初の実装（これはダメだった）\nCommand::new(\"powershell\")\n    .args([\"-Command\", &format!(\n        r#\"\n        $shell = New-Object -ComObject WScript.Shell\n        Start-Process claude -ArgumentList '{prompt}' -WindowStyle Minimized\n        Start-Sleep -Seconds 3\n        $shell.AppActivate('claude')\n        Start-Sleep -Milliseconds 500\n        $shell.SendKeys('y~')  // 信頼承認\n        Start-Sleep -Seconds 5\n        $shell.SendKeys('{prompt_text}~')\n        \"#\n    )])\n    .output()\n    .await?;\n```\n\nこのコードの問題点は複数ありました。\n\n1. `Start-Sleep`の待機時間がマシン負荷によってズレる\n2. `Minimized`状態のウィンドウへのキー送信がWindowsでは制限されている\n3. `AppActivate`で一瞬アクティブにしてもSendKeysが届かないケースがある\n\n結果として「分析中」のスピナーが永遠に回り続け、再起動するしかないという状況が頻発しました。\n\n### `--print`モードへの全面切り替えで解決\n\nClaude CLIには`-p`（print）モードと`--permission-mode bypassPermissions`オプションがあります。これを使えば、非対話モードで完全にstdoutへ結果が返ってきます。ウィンドウも開かず、タイミング依存のコードも不要。\n\n```rust\n// After: claude --print モードを使う\npub async fn scan_with_claude(project_path: &str) -> Result<ProjectMeta, String> {\n    let prompt = format!(\n        \"Analyze this project and return JSON with fields: \\\n         name, description, techStack, category, targetAudience. \\\n         Project path: {}\",\n        project_path\n    );\n\n    let output = Command::new(\"claude\")\n        .args([\n            \"-p\", &prompt,\n            \"--permission-mode\", \"bypassPermissions\",\n        ])\n        .current_dir(project_path)\n        .output()\n        .await\n        .map_err(|e| format!(\"Claude CLI error: {}\", e))?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    serde_json::from_str::<ProjectMeta>(&stdout)\n        .map_err(|e| format!(\"JSON parse error: {}\", e))\n}\n```\n\n実測で30〜120秒かかりますが、「止まる」ことはなくなりました。なお、Windowsで日本語パスを含むディレクトリから起動するとエンコーディング問題が起きるため、PowerShellの`Scripting.FileSystemObject`で8.3短縮パスに変換する回避策も実装しています。\n\n---\n\n## u8オーバーフローによるパニック\n\nポーリングでワークフローの進捗を取得するコードで、進捗率を計算する部分にバグがありました。\n\n```rust\n// Before: u8 オーバーフローで panic\nlet progress = retries as u8 * 50 / max_polls as u8;\n//             ^^^^^^^^^^^^^^^^\n// retries が 6 を超えると 300 になり u8(max=255) をオーバーフロー\n\n// After: usize で計算してから変換\nlet progress = (retries * 50 / max_polls).min(100) as u8;\n```\n\n「進捗表示のためだけの計算」がアプリをクラッシュさせていました。Rustのdebugビルドではオーバーフローがpanicになるため、開発中に発見できたのはまだ幸運でした。releaseビルドだとwrapして誤った値を返し続けるところでした。\n\n---\n\n## Tauri v2のIPC設計：useApiフックへの集約\n\nフロントエンドからRustのコマンドを呼ぶTauri v2のIPCは、`invoke<T>()`のジェネリクスで戻り値の型を指定できます。最初は各コンポーネントから直接`invoke`を呼んでいましたが、コマンド名の文字列が散在してリファクタリングが困難でした。\n\n```typescript\n// Before: 各コンポーネントで直接 invoke\nconst projects = await invoke<Project[]>('get_projects');\nconst meta = await invoke<ProjectMeta>('scan_project', { path });\n```\n\nこれを`useApi`フックに全IPC呼び出しを集約する設計に変更しました。\n\n```typescript\n// After: useApi フックに集約\nfunction createApi() {\n  return {\n    getProjects: () => invoke<Project[]>('get_projects'),\n    scanProject: (path: string) =>\n      invoke<ProjectMeta>('scan_project', { path }),\n    scanProjectWithClaude: (path: string) =>\n      invoke<ProjectMeta>('scan_project_with_claude', { path }),\n    triggerWorkflow: (slug: string, platforms: string[]) =>\n      invoke<void>('trigger_workflow', { slug, platforms }),\n    getAnalytics: () => invoke<Analytics>('get_analytics'),\n    syncSecrets: (tokens: ApiTokens) =>\n      invoke<void>('sync_github_secrets', { tokens }),\n  };\n}\n\nexport function useApi() {\n  // useMemo でメモ化しないと子コンポーネントが毎回再レンダーする\n  return useMemo(() => createApi(), []);\n}\n```\n\n`useMemo`によるメモ化は見落としやすいポイントです。`createApi()`が毎回新しいオブジェクトを返すと、このフックを使っている子コンポーネントがすべて再レンダーされます。依存配列を`[]`にすることでコンポーネントのライフタイム中に一度だけ生成されます。\n\n---\n\n## Gitリポジトリをデータストアとして使う設計\n\nmcw999-hubリポジトリを「データストア」として使い、デスクトップアプリとGitHub Actionsワークフローが同じJSONファイルを読み書きする設計を採用しています。\n\n```\nmcw999-hub/\n  content/\n    projects/\n      my-project.json    # プロジェクト定義\n    meta/\n      post-history.json  # 投稿履歴\n      traffic-history.json  # トラフィック累積データ\n```\n\nアナリティクスデータ更新時には`git stash → git pull --ff-only → git stash pop`の順序が重要でした。\n\n```rust\npub async fn refresh_analytics(repo_path: &str) -> Result<Analytics, String> {\n    // 1. ローカルの変更を退避\n    Command::new(\"git\")\n        .args([\"stash\"])\n        .current_dir(repo_path)\n        .output()\n        .await?;\n\n    // 2. リモートの最新を取得\n    Command::new(\"git\")\n        .args([\"pull\", \"--ff-only\"])\n        .current_dir(repo_path)\n        .output()\n        .await?;\n\n    // 3. GitHub Traffic API でデータ取得\n    let new_traffic = fetch_github_traffic().await?;\n\n    // 4. 既存データとマージして蓄積（14日制限の回避）\n    let history_path = format!(\"{}/content/meta/traffic-history.json\", repo_path);\n    let merged = merge_traffic_history(&history_path, &new_traffic)?;\n    tokio::fs::write(&history_path, serde_json::to_string_pretty(&merged)?).await?;\n\n    // 5. コミット・プッシュ\n    commit_and_push(repo_path, \"chore: update traffic history\").await?;\n\n    // 6. 退避した変更を復元（当初 stash drop にしていてデータを消失させた）\n    Command::new(\"git\")\n        .args([\"stash\", \"pop\"])\n        .current_dir(repo_path)\n        .output()\n        .await?;\n\n    Ok(Analytics { traffic: merged, /* ... */ })\n}\n```\n\n最初`stash drop`にしていたため、作業中の変更を消失させるバグがありました。`pop`に変えることで、リモートデータ取得とローカル変更の保護が両立します。\n\nGitHub Traffic APIは直近14日分しか返さないため、`traffic-history.json`に既存データとマージして蓄積することで長期間の推移を保持しています。\n\n---\n\n## プロジェクトスキャナーの実装\n\n`package.json`のdependenciesからフレームワークを逆引きする方法は、思ったより精度が高いです。\n\n```rust\nfn detect_tech_stack_from_npm(dependencies: &Map<String, Value>) -> Vec<String> {\n    let mappings = [\n        (\"react\",           \"React\"),\n        (\"next\",            \"Next.js\"),\n        (\"vue\",             \"Vue.js\"),\n        (\"svelte\",          \"Svelte\"),\n        (\"@angular/core\",   \"Angular\"),\n        (\"express\",         \"Express\"),\n        (\"@tailwindcss/vite\", \"TailwindCSS\"),\n        (\"tailwindcss\",     \"TailwindCSS\"),\n        (\"prisma\",          \"Prisma\"),\n        (\"drizzle-orm\",     \"Drizzle\"),\n        (\"mongoose\",        \"MongoDB\"),\n        (\"socket.io\",       \"Socket.io\"),\n        (\"three\",           \"Three.js\"),\n        (\"electron\",        \"Electron\"),\n        (\"@trpc/server\",    \"tRPC\"),\n    ];\n\n    let mut stack: Vec<String> = mappings\n        .iter()\n        .filter(|(dep, _)| dependencies.contains_key(*dep))\n        .map(|(_, name)| name.to_string())\n        .collect();\n\n    stack.dedup();\n    stack\n}\n```\n\nカテゴリ推論ではキーワードの優先順序が重要でした。`finance`より`crypto`を先にチェックしないと、「budget wallet」のような文字列が`finance`に誤分類されます。\n\n`.pr-meta.json`をプロジェクトルートに置く仕組みも導入しました。これがあれば0.5秒以下で完全なプロジェクト情報を取得できます。日本語フィールド（`nameJa`、`taglineJa`、`descriptionJa`）はファイルスキャンや依存関係解析では絶対に取れないため、この仕組みが不可欠です。\n\n---\n\n## プラットフォームごとの認証方式の違い\n\n各プラットフォームのAPI認証を実装して気づいたのは、方式がバラバラということです。\n\n```typescript\n// Qiita: Bearer トークン\nconst checkQiita = async (token: string) => {\n  const res = await fetch('https://qiita.com/api/v2/authenticated_user', {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const user = await res.json();\n  return user.id; // ユーザーID取得\n};\n\n// Dev.to: api-key ヘッダ\nconst checkDevto = async (apiKey: string) => {\n  const res = await fetch('https://dev.to/api/users/me', {\n    headers: { 'api-key': apiKey }\n  });\n  const user = await res.json();\n  return user.username;\n};\n\n// Zenn: 公開APIなし → 接続チェック不可能\n// Reddit: OAuth2が複雑すぎるため手動投稿を推奨\n```\n\nZennはAPIを公開していないので接続チェック自体が不可能、RedditはOAuth2が複雑すぎるため手動投稿を推奨する、という割り切りをUIに明示することでユーザーの混乱を防いでいます。\n\n---\n\n## 現在の状態と振り返り\n\n実装を通じて学んだことを整理すると：\n\n- **Claude CLIは`--print`モード一択**：GUI操作の自動化はタイミング依存で壊れやすい\n- **Rust の整数演算は型を意識する**：デバッグビルドでpanicになるのは早期発見の機会\n- **Gitリポジトリをデータストアにする**：ワークフローとアプリでデータを共有でき、変更履歴も自動でつく\n- **APIの制約はUIに明示する**：できないことを隠すより、できないと伝えた方がUXが上がる\n\nPRコンテンツ生成パイプライン全体の設計や実際の使い方については、以下のガイドも参照してください。\n\n---\n\n## 参考\n\n- [PRダッシュボード 使い方ガイド](https://mcw999.github.io/mcw999-hub/blog/pr-dashboard-guide/)\n- [Tauri v2 IPC Documentation](https://v2.tauri.app/develop/calling-rust/)\n- [Claude CLI Reference](https://docs.anthropic.com/en/docs/claude-cli)\n- [GitHub Traffic API](https://docs.github.com/en/rest/metrics/traffic)",
  "tags": [
    "個人開発",
    "PR自動化",
    "コンテンツ生成",
    "Claude AI",
    "Tauri"
  ]
}